# Iteration-1 학습

## 객체지향 생활체조 원칙

---

객체지향 생활체조 원칙 9가지

1. 한 메서드에 오직 한 단계의 들여 쓰기만 한다.
    
    한 메서드에 들여쓰기가 여러개 존재한다면, 해당 메서드는 여러가지 일을 하고 있다고 봐도 무관하다.
    메서드는 맡은 일이 적을수록, 재사용성이 높고 디버깅도 용이하다.
    메서드명을 통해 조금 더 직관적이면서도 나뉜 메서드를 다른데서도 재사용 가능한 코드가 된다.
    
2. else 예약어를 쓰지 않는다.
    
    조건문은 복제의 원인이 되기도 하고, 가독성도 좋지 않다.
    
    디자인패턴의 [Strategy 패턴](https://www.notion.so/Strategy-829710f3929c473198e553e7bcd45bcd) - 상태 인라인(status inline)의 분기를 막기 위한 다형성(polymorphism)예제가 있다.
    
    상태에 대한 분기가 몇 군데 걸쳐 중복되어 있을 때 Strategy 패턴은 특히 유용하다.
    
    간단한 경우엔 보호구문(guard clause) 사용 : if에 return을 쓸 것( early return) - 단, 많이 쓰면 간결함을 해칠 수 있다.
    
3. 모든 원시 값과 문자열을 포장한다.
    
    안티 패턴중 하나인 [Primitive Obsession](http://wiki.c2.com/?PrimitiveObsession)을 피하기 위해 객체 내의 모든 윈시요소를 캡슐화하자.
    
4. 한 줄에 점을 하나만 찍는다.
    
    (스트림 등 체이닝하는 일부를 제외)
    어느 코드 한 곳에서 점이 둘 이상 있다면, 해당 부분을 다시 리팩토링 해야한다.
    
    Demeter의 법칙 : “친구하고만 대화하라”
    
    자신 소유의 객체, 자신이 생성한 객체, 그리고 누군가 준 객체에만 메시지를 보낼 것
    
5. 줄여쓰지 않는다.
    
    과도한 축약은 코드 가독성을 저해한다. 
    
    메서드의 이름이 긴 이유중 하나는 책임을 너무 많이 갖고 있거나, 적절한 클래스의 아래에 위치하지 않아서 일 수 있다.
    
    한 두 단어정도로 되어있는 경우엔 축약하지 말고, 문맥상 중복되는 단어는 자제하자.
    
6. 모든 엔티티를 작게 유지한다.
    
    50줄 이상 되는 클래스 또는 10개 파일 이상의 패키지는 없어야한다.
    
    클래스가 길면 읽기 어렵다!
    
7. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
8. 일급 컬렉션을 쓴다. 
9. getter/setter/프로퍼티를 쓰지 않는다.

## JVM, JDK, JRE 란?

---

자바는 WORA(Write Once Run Anywhere)을 추구한다.
cpu마다 기계어가 다르고 운영체제마다 api, 실행파일 형식이 다르기 때문에 기존 프로그램은 플랫폼 종속성을 갖고 있었다. 하지만 java는 JVM을 사용해서 플랫폼 종속성을 해결했다.

### JVM (Java Virtual Machine)

- 플랫폼 종속성을 해결
- 자바 프로그램의 메모리를 효율적으로 관리 & 최적화(가비지 컬렉션)

### JRE (Java Runtime Environment)

- 자바 클래스 라이브러리 + JVM + 자바 클래스 로더

### JDK (Java Development Kit)

- JRE + javac(컴파일러) + 디버거 등
- 소스코드(.java)를 컴파일러가 바이트코드로 변환하고(.class) 해당 바이트 코드를 JVM이 플랫폼에 맞게 실행 시킨다.

## 쿠키와 세션은?

---

### 요약

- 공통점 : Connectionless, Stateless 프로토콜에서 웹 통신간 유지하려는 정보를 저장
- 차이점 : 저장위치, 저장형식, 용량제한, 만료시점 등

### 쿠키

HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우,그 사이트가 사용하고 있는 서버에서 **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.

HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장했다가 **필요시 정보를 참조하거나 재사용할 수 있다.**

- **쿠키 특징**
    1. 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
    2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
    3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다
    4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
- **쿠키의 동작 순서**
    1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
    2. 웹 서버는 쿠키를 생성한다.
    3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때,같이 클라이언트에게 돌려준다.
    4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장)다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
    5. 동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우,요청 페이지와 함께 쿠키를 전송한다.
- **사용 예시**
    1. 방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
    2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크

### 세션

일정 시간동안 같은 사용자(브라우저)로부터 들어오는일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다.

여기서 일정 시간은 방문자가 웹 브라우저를 통해웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션**이라고 한다.

- **세션 특징**
    1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
    2. 웹 서버의 저장되는 쿠키(=세션 쿠키)
    3. 브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로,쿠키보다 비교적 보안이 좋다.
    4. 저장 데이터에 제한이 없다.(서버 용량이 허용하는 한...)
    5. 각 클라이언트 고유 Session ID를 부여한다.Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공
- **세션의 동작 순서**
    1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
    2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,클라이언트가 해당 session-id를 보냈는지 확인한다.
    3. session-id가 존재하지 않는다면,서버는 session-id를 생성해 클라이언트에게 돌려준다.
    4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.쿠키 이름 : JSESSIONID
    5. 클라이언트는 재접속 시,이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달
- **사용 예시**
    - 화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

## RestFul API란?

---

### API란

Application Programming Interface 로 소프트웨어 인터페이스이고 웹API는 정보제공자와 정보사용자간의 계약이다. 

### REST란

REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미한다.

즉, 

1. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
2. HTTP Method(POST, GET, PUT, DELETE)를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미한다.

### **REST 구성 요소**

REST는 다음과 같은 3가지로 구성이 되어있다.

1. **자원(Resource) : HTTP URI**
2. **자원에 대한 행위(Verb) : HTTP Method**
3. **자원에 대한 행위의 내용 (Representations) : HTTP Message Pay Load**

### **REST의 특징**

1. Server-Client(서버-클라이언트 구조)
2. Stateless(무상태)
3. Cacheable(캐시 처리 가능)
4. Layered System(계층화)
5. Uniform Interface(인터페이스 일관성)

### **REST의 장단점**

장점

- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
- HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해 준다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
- Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
- 서버와 클라이언트의 역할을 명확하게 분리한다.

단점

- 표준이 자체가 존재하지 않아 정의가 필요하다.
- 사용할 수 있는 메소드가 4가지밖에 없다.
- HTTP Method 형태가 제한적이다.
- 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 정보의 값을 처리해야 하므로 전문성이 요구된다.
- 구형 브라우저에서 호환이 되지 않아 지원해주지 못하는 동작이 많다.(익스폴로어)

### **REST API 설계 예시**

**1. URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다.**

**2. 마지막에 슬래시 (/)를 포함하지 않는다.**

**3. 언더바 대신 하이폰을 사용한다.**

**4. 파일확장자는 URI에 포함하지 않는다.**

**5. 행위를 포함하지 않는다.**

### RESTful이란

REST의 원리를 따르는 시스템을 의미

## 주요 HTTP Status Code는?

---

### OK (2xx)

- 200 성공

### Bad Request (4xx)

- 400 잘못된 요청
- 401 권한없음 Unauthorized (인증실패)
- 403 금지됨 Forbidden (인가실패)
- 404 Not Found 요청 페이지 없음
- 405 허용되지 않는 메서드

### Server Error (5xx)

- 500 내부서버 오류

## Http Method 종류는?

---

### Get

리소스 조회

query를 이용해 서버에 데이터 전달

### Post

리소스 등록 / 프로세스 처리

메시지 바디를 이용해 서버로 요청데이터 전달

### Put

리소스 수정

리소스의 위치를 알고 uri를 지정해줘야함

### Patch

리소스 부분 수정

### Delete

리소스 삭제
